# Test Plan: Full DML Lifecycle WAL Generation (Physical vs. Logical)

**1. Objective**

To measure and compare the performance (runtime) and WAL volume generated by a full Data Manipulation Language (DML) lifecycle—`INSERT`, `UPDATE`, and `DELETE`—on a large dataset. This test will be conducted under both `replica` and `logical` `wal_level` configurations to precisely identify the overhead associated with each DML operation type.

**2. Hypothesis**

While the `INSERT` performance and WAL volume will be similar between the two modes (as demonstrated in previous tests), the `UPDATE` and `DELETE` operations will generate significantly more WAL data and potentially take longer under `wal_level = logical`. This is because `logical` decoding requires the WAL to contain enough information to reconstruct the row change, which for `UPDATE`s and `DELETE`s often means logging the old row's primary key or even the full old row—information not required for standard physical replication.

**3. Methodology**

A new Python script, `full_lifecycle_test.py`, will be developed to execute the three DML phases sequentially against a 1-million-row dataset. WAL statistics from the `pg_stat_wal` view will be captured before and after each individual phase (`INSERT`, `UPDATE`, `DELETE`) to isolate and calculate the precise WAL delta for each operation.

The test workflow is as follows:

```mermaid
graph TD
    subgraph Test Run 1: wal_level = replica
        A[Set wal_level = replica & Restart PG] --> B[Create Table];
        B --> C[Capture Stats (Before Insert)];
        C --> D[Run INSERT Phase];
        D --> E[Capture Stats (After Insert)];
        E --> F[Run UPDATE Phase];
        F --> G[Capture Stats (After Update)];
        G --> H[Run DELETE Phase];
        H --> I[Capture Stats (After Delete)];
    end

    subgraph Test Run 2: wal_level = logical
        J[Set wal_level = logical & Restart PG] --> K[Create Table];
        K --> L[Capture Stats (Before Insert)];
        L --> M[Run INSERT Phase];
        M --> N[Capture Stats (After Insert)];
        N --> O[Run UPDATE Phase];
        O --> P[Capture Stats (After Update)];
        P --> Q[Run DELETE Phase];
        Q --> R[Capture Stats (After Delete)];
    end

    subgraph Analysis
        S[Calculate Deltas for all 6 phases];
        S --> T[Generate Comparative Report];
    end

    I --> J;
    R --> S;
```

**4. Detailed Steps**

1.  **Create New Test Script:** Develop `full_lifecycle_test.py`. This script will contain three distinct, parallelized functions for:
    *   Inserting 1,000,000 rows.
    *   Updating all 1,000,000 of those rows (e.g., modifying the `payload` column).
    *   Deleting all 1,000,000 rows.
    All operations will be performed in batches of 100.

2.  **Execute Test Run 1 (`replica`):**
    *   Set `wal_level = replica` in `postgres-config/postgresql.conf` and restart the `postgres` container.
    *   Run `setup_test_tables.sql` to create a clean `logged_bulk_test` table.
    *   **Capture WAL stats (T1).**
    *   Run the `INSERT` phase of the script and record its execution time.
    *   **Capture WAL stats (T2).**
    *   Run the `UPDATE` phase of the script and record its execution time.
    *   **Capture WAL stats (T3).**
    *   Run the `DELETE` phase of the script and record its execution time.
    *   **Capture WAL stats (T4).**

3.  **Execute Test Run 2 (`logical`):**
    *   Set `wal_level = logical` in `postgresql.conf` and restart the `postgres` container.
    *   Run `setup_test_tables.sql`.
    *   **Capture WAL stats (T5).**
    *   Run the `INSERT` phase and record its time.
    *   **Capture WAL stats (T6).**
    *   Run the `UPDATE` phase and record its time.
    *   **Capture WAL stats (T7).**
    *   Run the `DELETE` phase and record its time.
    *   **Capture WAL stats (T8).**

4.  **Analysis & Reporting:**
    *   Calculate the WAL deltas for each of the six distinct phases (e.g., Replica Insert = T2 - T1, Replica Update = T3 - T2, etc.).
    *   Create a new report file, `full_lifecycle_wal_test_results.md`.
    *   The report will contain a detailed table comparing the `wal_records`, `wal_bytes`, and `execution_time` for each DML operation across both `wal_level` settings.
    *   Provide a written analysis of the findings, focusing on the overhead of `UPDATE` and `DELETE` operations.

5.  **Cleanup:**
    *   Drop the `logged_bulk_test` table from the database.
    *   Per the user's request, the test plan, the new test script, and the final report **will not be deleted**.