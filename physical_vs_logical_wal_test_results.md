# Test Results: Physical (`replica`) vs. Logical WAL Generation

This document presents the results of the WAL (Write-Ahead Log) generation test comparing PostgreSQL's `replica` and `logical` `wal_level` settings. The test involved inserting 1 million rows into a standard `LOGGED` table under each configuration.

## I. Test Execution Summary

*   **Workload:** 1,000,000 rows inserted into `logged_bulk_test`.
*   **Parallelism:** 10 concurrent processes.
*   **Batch Size:** 1,000 rows per transaction batch.

### Performance Observations

*   **`wal_level = replica` duration:** 21.66 seconds
*   **`wal_level = logical` duration:** 17.28 seconds

The data load was approximately **20% faster** when `wal_level` was set to `logical`. This is an interesting and somewhat counter-intuitive result, possibly related to the specifics of I/O patterns or checkpointing behavior under the different modes for this specific workload.

## II. WAL Generation Comparison

The following table shows the delta in WAL statistics (After - Before) for each test run.

| Metric        | `wal_level = replica` (Delta) | `wal_level = logical` (Delta) | Increase Factor |
|---------------|-------------------------------|-------------------------------|-----------------|
| `wal_records` | 2,004,722                     | 2,004,727                     | ~1.0x (Negligible) |
| `wal_bytes`   | 189,133,086 (~180.4 MB)       | 189,176,940 (~180.4 MB)       | ~1.0x (Negligible) |

## III. Analysis and Conclusion

The results of this test are surprising and contradict the initial hypothesis. For this specific bulk-insert workload, there was **no significant difference** in the volume of WAL data generated between the `replica` and `logical` WAL levels.

**Initial Hypothesis (Disproven):** The `logical` level was expected to generate significantly more WAL data due to the need to store logical change information.

**Observed Result:** Both configurations produced nearly identical amounts of WAL data (~180.4 MB). The number of WAL records was also virtually identical.

**Possible Explanations:**

1.  **Bulk `INSERT` Optimization:** It is possible that for `INSERT`-only workloads, the overhead of logical decoding is minimal. The information required for `logical` decoding of an `INSERT` (the full new row) is already present in the physical WAL record generated by a standard `INSERT` operation. The significant overhead for `logical` replication typically comes from `UPDATE` and `DELETE` operations, where PostgreSQL must log extra information (like the old primary key or the full old row) that would not be present in a `replica`-level WAL record.

2.  **Full Page Writes:** During a bulk load, many new pages are written to disk for the first time. PostgreSQL's `full_page_writes` setting, which is on by default, writes the entire content of a disk page to WAL after a checkpoint. This behavior, designed to prevent data corruption from partial writes, could be the dominant factor in WAL volume for this test, dwarfing the subtle differences between `replica` and `logical` WAL records for `INSERT`s.

**Conclusion:**

For high-volume, `INSERT`-only workloads, changing `wal_level` from `replica` to `logical` does not appear to introduce a significant WAL I/O penalty. The primary overhead of logical replication likely lies in the processing of `UPDATE` and `DELETE` statements.

This finding is valuable, as it suggests that enabling logical replication for a system that primarily ingests new data may not have the negative performance impact on write throughput that is often assumed. A follow-up test focusing on `UPDATE` operations would be necessary to measure the full overhead of the `logical` setting.